# Содержание

- [Что такое .editorconfig](#что-такое-editorconfig)
- [Что такое .eslintrc.json](#что-такое-eslintrcjson)
- [Почему `node-sass` и SCSS модули а не просто CSS?](#почему-node-sass-и-scss-модули-а-не-просто-css)

# Что такое .editorconfig

Это небольшой файл, который влияет на настройки WebStorm-а.

### Зачем на них влиять?

Когда в команде 100500 человек, сложно следить за всеми, чтобы все писали код в одном стиле, чтобы все следили за определенными вещами.
Гораздо проще написать конфиг файлик один раз и положить его в репозиторий.
Этот файлик будет скачан каждым учасником проекта и все будут иметь одни и те же настройки.

### А что там за настройки?

```
indent_style = space
indent_size = 2
```
Настройки отступов при переходе на следующую строку.

```
charset = utf-8
```
Кодировка кода.

```
trim_trailing_whitespace = true
```
Удаление ненужных пробелов вконце строки кода.

```
insert_final_newline = true
```
Добавление пустой строки вконце файла.

- Если спросят "а зачем?" - отвечай "Зачем-то так для гита. Зачем конкретно - не помню."
- Если скажут что "Это не обязательно или не нужно" - спроси "А почему в репозиториях Реакта, Ангуляра и Вью стоит эта настройка?"

```
max_line_length = 100
```
Устанавливает положение серой вертикальной линии в WebStorm, чтобы видно было глазами ограничение, за которое "нельзя" вылазить при написании кода.
Почему нельзя вылазить? Скролить вверх вниз легко. Скролить влево вправа дико неудобно.
Поэтому разработчики ставят "ограничения" на длинну строки кода, чтобы при открытии файлов не нужно было скроли горизонтально.

```
end_of_line = lf
```
Перенос строки - это символ. У винды и юникс систем (линукс и мак) символ переноса строки разный.
У Винды вроде бы `crlf`, у юникс систем `lf`.
Эта настройка говорит WebStorm-у игнорировать символ операционки и использовать установленный.

Зачем? Если у тебя винда, а у меня линукс и я последний закомитил файл в репозиторий, то стоит тебе с винды его "потрогать",
как видна поменяет символ переноса строки на виндовский. С точки зрения разраба в файле визуально ничего не поменялось,
но для гита поменялся один символ и он будет просить закомитить изменения, которые не видны на экране.
Будут вопросы: а что ты поменяла? ничего? тогда почему файл светится как измененный? ревертни и все такое.
Проще иметь одинаковый символ переноса среди всех учасников проекта.

Почему `lf`? Потому что винда - кусок говнища, которая годится только для того, чтобы в игрушки играть.

# Что такое .eslintrc.json

Это файл настройки EsLint. EsLint этот либа, которая проверяет код на "правильность" с разных сторон.

Почему настройки в одтельном файле, а не в `package.json`? Чтобы было чище и "зона ответственности".

`extends` - расширяет стандартные проверки EsLint-а реактовскими, чтобы EsLint не ругался на реакт код.
`rules` - это кастомные настройки правил проверки кода.

# Почему `node-sass` и SCSS модули а не просто CSS?

У обычного CSS есть две основные проблемы, которых нету в SCSS модулях:

1. конфликт имен
2. некомфортный синтаксис

### Конфликт имен

SCSS модули позволяют не используя абсолютно никаких подходов не думать о проблеме конфликта имен классов.

Класс `.container` в одном CSS файле будет конфиктовать с классом `.container` в другом CSS файле.
В случае SCSS модулей конфликта не будет, потому что при запуске кода Реакт переименует эти классы в уникальные.

Если не кастомизировать это поведение, то по умолчанию получившееся имя класса будет выглядеть как-то так: `Module_class__UniqStringLenght5`.
Например `Button_container__Qb-Hu`, где `Button` это имя модуля `Button.module.scss`,
`container` это SCSS класс, а `Qb-Hu` это уникальная строка из случайных символов.

### Некомфортный синтаксис

SCSS (как и другие CSS препроцессоры) "расширяет" синтаксис CSS-а. Одним из таких расширений является "вложенность".

В CSS чтобы дать стили классу `.title` только в том случае, если он лежит в классе `.container`, нужно будет написать:

```css
.container {
  // стили контейнера
}

.container .title {
  // стили тайтла, который лежит в контейнере
}
```

Усложним:

```css
.container {
  // some styles
}

.container .section {
  // some styles
}

.container .section .title {
  // some styles
}

.container .section:not(:first-child) {
  // some styles
}

.container .section:not(:first-child) .title {
  // some styles
}
```

Перепишем на SCSS:

```scss
.container {
  // some styles
  
  .section {
    // some styles
    
    &:not(:first-child) {
      // some styles
      
      .title {
        // some styles
      }
    }
    
    .title {
      // some styles
    }
  }
}
```

SCSS (как и другие CSS препроцессоры) расширяет синтаксис CSS многим другим, что уменьшает общую боль от написания стилей.
